<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>勤怠管理表 簡易ビューア</title>
  <style>
    :root {
      --primary-color: #4a6da7;
      --secondary-color: #f5f7fa;
      --accent-color: #5c8bdc;
      --text-color: #333;
      --border-color: #ddd;
      --error-color: #e74c3c;
      --success-color: #2ecc71;
    }
    
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    
    body {
      font-family: 'Hiragino Sans', 'Hiragino Kaku Gothic ProN', Meiryo, sans-serif;
      line-height: 1.6;
      color: var(--text-color);
      background-color: #f9f9f9;
      padding: 16px;
    }
    
    .container {
      max-width: 800px;
      margin: 0 auto;
      background-color: white;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      padding: 24px;
    }
    
    h1 {
      font-size: 1.5rem;
      color: var(--primary-color);
      margin-bottom: 1.5rem;
      text-align: center;
      font-weight: 600;
    }
    
    #attendance {
      margin-top: 1.5rem;
    }
    
    .empty-result {
      text-align: center;
      padding: 20px;
      color: #777;
      font-style: italic;
    }
    
    .error {
      color: var(--error-color);
      margin-top: 1rem;
      padding: 10px;
      background-color: rgba(231, 76, 60, 0.1);
      border-radius: 4px;
      display: none;
    }
    
    .loading {
      text-align: center;
      padding: 20px;
      color: #555;
    }
    
    .loading::after {
      content: "...";
      animation: dots 1.5s infinite;
    }
    
    @keyframes dots {
      0%, 20% { content: "."; }
      40% { content: ".."; }
      60%, 100% { content: "..."; }
    }
    
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 1rem;
      font-size: 0.95rem;
    }
    
    th, td {
      padding: 12px 8px;
      border: 1px solid var(--border-color);
      text-align: left;
    }
    
    th {
      background-color: var(--secondary-color);
      font-weight: 600;
      position: sticky;
      top: 0;
      z-index: 10;
    }
    
    tr:nth-child(even) {
      background-color: #f9f9f9;
    }
    
    tr:hover {
      background-color: #f0f4f8;
    }
    
    .time-value {
      font-family: monospace;
      white-space: nowrap;
    }
    
    .events-cell {
      font-size: 0.9rem;
    }
    
    .text-success {
      color: var(--success-color);
      font-weight: bold;
    }
    
    .text-danger {
      color: var(--error-color);
      font-weight: bold;
    }
    
    .browser-error {
      text-align: center;
      padding: 30px 20px;
      color: var(--error-color);
      font-weight: bold;
    }
    
    .browser-error p {
      margin-bottom: 10px;
    }
    
    .user-info {
      text-align: center;
      margin-bottom: 20px;
      font-size: 0.9rem;
      color: #666;
    }
    
    .user-name {
      font-weight: bold;
      color: var(--primary-color);
    }
    
    /* 手動入力フォーム用のスタイル */
    .manual-form {
      background-color: var(--secondary-color);
      padding: 15px;
      border-radius: 6px;
      margin-bottom: 20px;
    }
    
    .form-row {
      margin-bottom: 12px;
    }
    
    .form-row label {
      display: block;
      margin-bottom: 4px;
      font-weight: 500;
      font-size: 0.9em;
    }
    
    .form-row input {
      width: 100%;
      padding: 8px;
      border: 1px solid var(--border-color);
      border-radius: 4px;
      font-size: 16px;
    }
    
    .form-row button {
      background-color: var(--primary-color);
      color: white;
      border: none;
      padding: 10px 15px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 16px;
      width: 100%;
    }
    
    .form-row button:hover {
      background-color: var(--accent-color);
    }
    
    .form-toggle {
      text-align: center;
      margin-top: 15px;
      font-size: 0.9em;
      color: var(--accent-color);
      cursor: pointer;
      text-decoration: underline;
    }
    
    @media (max-width: 600px) {
      .container {
        padding: 16px 12px;
      }
      
      th, td {
        padding: 8px 4px;
        font-size: 0.85rem;
      }
      
      .events-cell {
        font-size: 0.8rem;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>勤怠管理表</h1>
    
    <div id="user-display" class="user-info" style="display: none;">
      <!-- <div class="loading">ユーザー情報を読み込み中</div> -->
    </div>
    
    <div class="controls" style="margin-bottom: 1.5rem; text-align: center;">
      <label for="month-year-selector" style="margin-right: 8px; font-weight: 500;">表示月:</label>
      <select id="month-year-selector" style="padding: 8px 12px; border-radius: 4px; border: 1px solid var(--border-color); font-size: 16px; background-color: #fff; max-width: 150px; cursor: pointer; appearance: auto;">
        <!-- 選択肢はJavaScriptで動的に生成 -->
      </select>
    </div>
    
    <div id="browser-error" class="browser-error" style="display: none;">
      <p>このページはLINEアプリからのみアクセスできます。</p>
      <p>勤怠確認はLINEアプリから行ってください。</p>
    </div>
    
    <div id="attendance"></div>
    <div class="error" id="error"></div>
    
    <div class="summary-section" style="margin-top: 1.5rem; padding: 15px; background-color: var(--secondary-color); border-radius: 6px; display: flex; justify-content: space-around;">
      <div>総労働時間: <span id="total-work-time">-</span></div>
      <div>総休憩時間: <span id="total-break-time">-</span></div>
      <div>実働日数: <span id="work-days">-</span></div>
    </div>
    
    <!-- 問題診断ボタン（通常は非表示） -->
    <div id="debug-section" style="margin-top: 20px; display: none; text-align: center;">
      <button id="debug-button" style="padding: 8px 15px; background-color: #f5f5f5; border: 1px solid #ddd; border-radius: 4px;">問題診断</button>
      <div id="debug-info" style="margin-top: 10px; padding: 10px; border: 1px solid #ddd; border-radius: 4px; background-color: #f9f9f9; display: none; text-align: left; font-size: 0.8rem;"></div>
    </div>
  </div>
  
  <!-- LIFF SDK -->
  <script charset="utf-8" src="https://static.line-scdn.net/liff/edge/2/sdk.js"></script>
  
  <script>
    // 最新のAPIエンドポイント
    const API_URL = 'https://script.google.com/macros/s/AKfycbxCrXq-iEvolakShQ6b55cjxoYRpYqq1Nxl2EYcpRFG1TNYq58vzvBsI9aH3lY7gMM/exec';
    let isLiffInitialized = false;
    let currentLineUserId = null;
    
    // ページ読み込み時にLIFFを初期化
    document.addEventListener('DOMContentLoaded', function() {
      // クエリパラメータからデバッグモードを確認
      const urlParams = new URLSearchParams(window.location.search);
      const isDebugMode = urlParams.get('debug') === 'true';
      const isTestMode = urlParams.get('test') === 'true';
      
      // テストモードの場合はテストデータを表示
      if (isTestMode) {
        console.log('テストモード：サンプルデータを表示します');
        renderTestData();
        return;
      }
      
      // デバッグモードなら問題診断ボタンを表示
      if (isDebugMode) {
        document.getElementById('debug-section').style.display = 'block';
        
        // 問題診断ボタンのイベントリスナー
        document.getElementById('debug-button').addEventListener('click', function() {
          const debugInfoEl = document.getElementById('debug-info');
          
          // システム情報を収集
          let debugInfo = '';
          
          // LIFF情報
          debugInfo += '<h4>LIFF情報</h4>';
          debugInfo += `<p>LIFF初期化: ${isLiffInitialized ? '成功' : '未完了'}</p>`;
          
          if (window.liff) {
            try {
              debugInfo += `<p>LIFF SDK: 利用可能</p>`;
              debugInfo += `<p>LINEアプリ内: ${liff.isInClient() ? 'はい' : 'いいえ'}</p>`;
              debugInfo += `<p>ログイン状態: ${liff.isLoggedIn() ? 'ログイン済み' : '未ログイン'}</p>`;
            } catch (e) {
              debugInfo += `<p>LIFF情報エラー: ${e.message}</p>`;
            }
          } else {
            debugInfo += `<p>LIFF SDK: 利用不可</p>`;
          }
          
          // ブラウザ情報
          debugInfo += '<h4>ブラウザ情報</h4>';
          debugInfo += `<p>User Agent: ${navigator.userAgent}</p>`;
          
          // API情報
          debugInfo += '<h4>API情報</h4>';
          debugInfo += `<p>エンドポイント: ${API_URL}</p>`;
          
          // LINE UserID情報
          if (currentLineUserId) {
            debugInfo += '<h4>LINE情報</h4>';
            debugInfo += `<p>LINE User ID: ${currentLineUserId}</p>`;
          }
          
          // ユーザーへの指示
          debugInfo += '<h4>問題解決手順</h4>';
          debugInfo += '<ol>';
          debugInfo += '<li>LINEボットに「出勤」や「退勤」などのコマンドを送り、打刻してください</li>';
          debugInfo += '<li>問題が解決しない場合は、管理者に表示されているLINE User IDを伝えてください</li>';
          debugInfo += '</ol>';
          
          // 表示/非表示を切り替え
          if (debugInfoEl.style.display === 'none') {
            debugInfoEl.innerHTML = debugInfo;
            debugInfoEl.style.display = 'block';
          } else {
            debugInfoEl.style.display = 'none';
          }
        });
      }
      
      // LIFF初期化を実行
      initializeLiff().catch(error => {
        console.error('初期化エラー:', error);
        showError('アプリの初期化中にエラーが発生しました。');
      });
    });
    
    // 月年セレクターを生成 (例: 過去12ヶ月)
    function populateMonthYearSelector() {
        const select = document.getElementById('month-year-selector');
        if (!select) {
            console.error('[DEBUG] month-year-selectorが見つかりません');
            return;
        }
        
        // 既存の選択肢をクリア
        select.innerHTML = '';
        
        // イベントリスナーの削除（重複登録防止）
        select.removeEventListener('change', handleMonthYearChange);
        
        const today = new Date();
        // 今月と過去11ヶ月分の選択肢を追加
        for (let i = 0; i < 12; i++) {
            let date = new Date(today.getFullYear(), today.getMonth() - i, 1);
            let year = date.getFullYear();
            let month = date.getMonth() + 1;
            let option = document.createElement('option');
            option.value = `${year}-${month.toString().padStart(2, '0')}`;
            option.textContent = `${year}年${month}月`;
            select.appendChild(option);
        }
        
        // イベントリスナーを追加
        select.addEventListener('change', handleMonthYearChange);
        
        console.log('[DEBUG] 月年セレクター初期化完了 - 選択肢数:', select.options.length);
    }
    
    // 月年変更イベントハンドラ（別関数化して重複登録防止）
    function handleMonthYearChange(event) {
        const selectedMonthYear = event.target.value;
        if (currentLineUserId && selectedMonthYear) {
            const [year, month] = selectedMonthYear.split('-');
            console.log(`月年変更: ${year}年${month}月`);
            fetchUserAttendance(currentLineUserId, parseInt(year), parseInt(month));
        } else {
            console.warn('[DEBUG] 月年変更 - ユーザーIDまたは選択値が不正:', 
                         'UserID:', currentLineUserId, 
                         'Selected:', selectedMonthYear);
        }
    }
    
    // LIFFの初期化
    async function initializeLiff() {
      try {
        // 開発者モードチェック（クエリパラメータ）
        const urlParams = new URLSearchParams(window.location.search);
        const isDevMode = urlParams.get('dev') === 'true';
        
        if (isDevMode) {
          console.log('開発者モード: LIFF初期化をスキップします');
          const mockUserId = urlParams.get('mockUserId');
          if (mockUserId) {
            // ユーザーIDを保存
            currentLineUserId = mockUserId;
            
            // 月年セレクターを初期化
            populateMonthYearSelector();
            
                      // 初回データ取得 (セレクターの現在の値に基づいて)
          const selector = document.getElementById('month-year-selector');
          if (selector && selector.value) {
              const [year, month] = selector.value.split('-');
              console.log(`初回データ取得: ${year}年${month}月`);
              await fetchUserAttendance(mockUserId, parseInt(year), parseInt(month));
          } else {
              // フォールバックとして当月データを取得
              const today = new Date();
              console.log(`初回データ取得（フォールバック）: ${today.getFullYear()}年${today.getMonth() + 1}月`);
              await fetchUserAttendance(mockUserId, today.getFullYear(), today.getMonth() + 1);
          }
          } else {
            showError('開発者モードでは mockUserId パラメータが必要です');
          }
          return;
        }
        
        // LINEブラウザチェック
        if (!window.liff) {
          console.error('LIFF SDKが利用できません。LINEアプリで開いてください。');
          showBrowserError();
          return;
        }
        
        // LIFF初期化
        await liff.init({ liffId: '2007458955-dVkEPq4E' }); // 実際のLIFF ID
        isLiffInitialized = true;
        console.log('LIFF初期化成功');
        
        // LINEブラウザで開かれているか確認
        if (!liff.isInClient()) {
          console.error('このページはLINEアプリからのみアクセスできます');
          showBrowserError();
          return;
        }
        
        // ユーザープロフィールから勤怠データを取得
        try {
          // LINEのユーザープロフィールを取得
          console.log('ユーザープロフィール取得中...');
          const profile = await liff.getProfile();
          console.log('プロフィール取得成功:', profile.displayName);
          const lineUserId = profile.userId;
          console.log('取得したLINE UserID:', lineUserId);
          
          // LINE UserIDを保存（デバッグ用）
          currentLineUserId = lineUserId;
          
          // 月年セレクターを初期化・設定
          populateMonthYearSelector(); 

          // 初回データ取得 (セレクターの現在の値に基づいて)
          const selector = document.getElementById('month-year-selector');
          if (selector && selector.value) {
              const [year, month] = selector.value.split('-');
              console.log(`初回データ取得(LINE認証): ${year}年${month}月`);
              await fetchUserAttendance(lineUserId, parseInt(year), parseInt(month));
          } else {
            // フォールバックとして当月データを取得 (セレクターが何らかの理由で空の場合)
            const today = new Date();
            console.log(`初回データ取得（LINE認証・フォールバック）: ${today.getFullYear()}年${today.getMonth() + 1}月`);
            await fetchUserAttendance(lineUserId, today.getFullYear(), today.getMonth() + 1);
          }
          
        } catch (profileError) {
          console.error('プロフィール取得失敗:', profileError);
          showError('LINEプロフィールの取得に失敗しました: ' + profileError.message);
        }
        
      } catch (err) {
        console.error('LIFF初期化エラー:', err.message, err.stack);
        showError('LINEへの接続に失敗しました。しばらく経ってからもう一度お試しください。');
      }
    }
    
    // ブラウザエラー表示
    function showBrowserError() {
      document.getElementById('user-display').style.display = 'none';
      document.getElementById('browser-error').style.display = 'block';
      document.getElementById('attendance').style.display = 'none';
    }
    
    // LINE認証での勤怠データ取得
    async function fetchUserAttendance(lineUserId, year, month) {
      const attendanceEl = document.getElementById('attendance');
      const errorEl = document.getElementById('error');
      
      try {
        // ローディング表示
        attendanceEl.innerHTML = '<div class="loading">勤怠データを取得中</div>';
        
        console.log('[DEBUG] fetchUserAttendance - Received lineUserId:', lineUserId, 'Year:', year, 'Month:', month);

        if (!lineUserId) {
          console.error('[DEBUG] lineUserId is null or empty. Throwing error.');
          throw new Error('ユーザーIDを取得できませんでした');
        }
        
        // APIリクエストURLを構築
        const currentDate = new Date();
        const requestYear = year || currentDate.getFullYear();
        const requestMonth = month || (currentDate.getMonth() + 1);

        let url = `${API_URL}?action=getMonthlyAttendance&lineUserId=${encodeURIComponent(lineUserId)}&year=${requestYear}&month=${requestMonth.toString().padStart(2, '0')}`;
        
        // デバッグモードの判定
        const urlParams = new URLSearchParams(window.location.search);
        const isDebugMode = urlParams.get('debug') === 'true';
        if (isDebugMode) {
          url += '&debug=true';
        }
        
        console.log('[DEBUG] 勤怠データ取得URL (APIリクエスト):', url);
        
        // JSONPアプローチを使用してCORSを回避
        return new Promise((resolve, reject) => {
          // 一意のコールバック関数名を生成
          const callbackName = 'jsonpCallback_' + Math.random().toString(36).substring(2, 15);
          
          // グローバルにコールバック関数を定義
          window[callbackName] = function(data) {
            try {
              // 処理完了後にスクリプトタグとコールバック関数を削除
              if (script && script.parentNode) {
                document.body.removeChild(script);
              }
              delete window[callbackName];
              
              // コンソールにデータを出力（デバッグ用）
              console.log('[DEBUG] JSONP応答受信:', data);
              
              if (data.status === 'error' || data.error) {
                console.error('APIエラー:', data);
                showError(data.message || data.error || 'データ取得エラー');
                attendanceEl.innerHTML = '';
                reject(new Error(data.message || data.error || 'データ取得エラー'));
                return;
              }
              
              // データが配列かどうかを確認
              if (Array.isArray(data)) {
                if (data.length > 0) {
                  console.log('有効なデータを受信しました。表示処理を開始します。');
                  renderTable(data, requestYear, requestMonth);
                  resolve(data);
                } else {
                  // データは配列だが空の場合（勤怠記録なし）
                  console.warn('[DEBUG] 勤怠データが空の配列です。LINE UserID:', lineUserId);
                  
                  // デバッグモードの場合はユーザーIDも表示
                  if (isDebugMode) {
                    attendanceEl.innerHTML = `<div class="empty-result">今月の勤怠記録はありません。<br><br>以下の理由が考えられます：<br>・打刻データが登録されていない<br>・LINE UserIDと従業員情報が正しく紐づけられていない<br><br>あなたのLINE User ID:<br>${lineUserId}<br><br>LINEボットに「出勤」や「退勤」などのコマンドを送信してください。</div>`;
                  } else {
                    attendanceEl.innerHTML = '<div class="empty-result">今月の勤怠記録はありません。<br><br>以下の理由が考えられます：<br>・打刻データが登録されていない<br>・LINE UserIDと従業員情報が正しく紐づけられていない<br><br>LINEボットに「出勤」や「退勤」などのコマンドを送信してください。</div>';
                  }
                  resolve([]);
                }
              } else {
                // 配列でない場合、オブジェクトである可能性を確認
                if (typeof data === 'object' && data !== null) {
                  console.warn('[DEBUG] APIから配列ではなくオブジェクトを受信しました:', data);
                  
                  // オブジェクトの可能性がある場合は変換を試みる
                  try {
                    // データがオブジェクトのプロパティ内にある可能性がある
                    if (data.data && Array.isArray(data.data)) {
                      console.log('[DEBUG] data.dataプロパティから配列を取得しました');
                      renderTable(data.data, requestYear, requestMonth);
                      resolve(data.data);
                      return;
                    }
                    
                    // オブジェクトを配列に変換して表示
                    if (Object.keys(data).length > 0) {
                      console.log('[DEBUG] オブジェクトを配列に変換して表示します');
                      
                      // オブジェクトを配列に変換
                      const recordsArray = Object.entries(data).map(([key, value]) => {
                        if (typeof value === 'object' && value !== null) {
                          // キーをdateとして使用する可能性
                          if (!value.date) {
                            value.date = key;
                          }
                          return value;
                        }
                        return null;
                      }).filter(item => item !== null);
                      
                      if (recordsArray.length > 0) {
                        console.log('[DEBUG] 変換後の配列:', recordsArray);
                        renderTable(recordsArray, requestYear, requestMonth);
                        resolve(recordsArray);
                        return;
                      }
                    }
                  } catch (conversionError) {
                    console.error('[DEBUG] データ変換エラー:', conversionError);
                  }
                }
                
                console.error('[DEBUG] 予期しないデータ形式:', data);
                showError('予期しないデータ形式を受信しました。');
                attendanceEl.innerHTML = '';
                reject(new Error('予期しないデータ形式を受信しました'));
              }
            } catch (callbackError) {
              console.error('[DEBUG] コールバック処理エラー:', callbackError);
              showError(`データ処理中にエラーが発生しました: ${callbackError.message}`);
              attendanceEl.innerHTML = '';
              reject(callbackError);
            }
          };
          
          // JSONP用のURLにコールバックパラメータを追加
          const jsonpUrl = `${url}&callback=${callbackName}`;
          
          // スクリプトタグを作成して読み込み
          const script = document.createElement('script');
          script.src = jsonpUrl;
          
          // タイムアウト処理
          const timeoutId = setTimeout(() => {
            // タイムアウト時の処理
            if (window[callbackName]) {
              delete window[callbackName];
              if (script && script.parentNode) {
                document.body.removeChild(script);
              }
              showError('APIリクエストがタイムアウトしました。ネットワーク接続を確認してください。');
              attendanceEl.innerHTML = '';
              reject(new Error('APIリクエストがタイムアウトしました'));
            }
          }, 15000); // タイムアウト時間を延長
          
          script.onload = function() {
            clearTimeout(timeoutId);
          };
          
          script.onerror = function(e) {
            clearTimeout(timeoutId);
            delete window[callbackName];
            if (script && script.parentNode) {
              document.body.removeChild(script);
            }
            console.error('[DEBUG] スクリプト読み込みエラー:', e);
            showError('APIリクエスト中にエラーが発生しました。サーバーに接続できません。');
            attendanceEl.innerHTML = '';
            reject(new Error('スクリプト読み込みエラー'));
          };
          
          // DOMに追加して読み込みを開始
          document.body.appendChild(script);
        });
      } catch (fetchError) {
        console.error('[DEBUG] APIリクエスト/処理エラー:', fetchError);
        
        showError(`データ取得中にエラーが発生しました: ${fetchError.message}`);
        attendanceEl.innerHTML = '';
        throw fetchError;
      }
    }
    
    // デバッグ用：テスト表示
    function renderTestData() {
      // 現在の年月を取得
      const now = new Date();
      const year = now.getFullYear();
      const month = now.getMonth() + 1;
      
      // 今月の1日、2日、3日のデータを作成
      const day1 = `${year}-${month.toString().padStart(2, '0')}-01`;
      const day2 = `${year}-${month.toString().padStart(2, '0')}-02`;
      const day3 = `${year}-${month.toString().padStart(2, '0')}-03`;
      
      const testData = [
        {
          "date": day1,
          "clockEvents": [
            {"type": "出勤", "time": "09:00:00"},
            {"type": "休憩開始", "time": "12:00:00"},
            {"type": "休憩終了", "time": "13:00:00"},
            {"type": "退勤", "time": "18:00:00"}
          ],
          "workStart": "09:00:00",
          "workEnd": "18:00:00",
          "workingHours": "8.00",
          "breakMinutes": "60"
        },
        {
          "date": day2,
          "clockEvents": [
            {"type": "出勤", "time": "08:30:00"},
            {"type": "休憩開始", "time": "12:30:00"},
            {"type": "休憩終了", "time": "13:30:00"},
            {"type": "退勤", "time": "17:30:00"}
          ],
          "workStart": "08:30:00",
          "workEnd": "17:30:00",
          "workingHours": "8.00",
          "breakMinutes": "60"
        },
        {
          "date": day3,
          "clockEvents": [
            {"type": "出勤", "time": "10:00:00"},
            {"type": "休憩開始", "time": "13:00:00"},
            {"type": "休憩終了", "time": "14:00:00"},
            {"type": "退勤", "time": "16:00:00"}
          ],
          "workStart": "10:00:00",
          "workEnd": "16:00:00",
          "workingHours": "5.00",
          "breakMinutes": "60"
        }
      ];
      renderTable(testData);
    }
    
    // エラーメッセージ表示
    function showError(message) {
      const errorEl = document.getElementById('error');
      if (!errorEl) {
        console.error('[DEBUG] エラー表示要素が見つかりません。メッセージ:', message);
        return;
      }
      errorEl.textContent = message;
      errorEl.style.display = 'block';
      console.error('[DEBUG] エラー表示:', message);
      
      // 5秒後に自動的に消える
      setTimeout(() => {
        errorEl.style.display = 'none';
      }, 5000);
    }
    
    function renderTable(records, year, month) {
      const attendanceEl = document.getElementById('attendance');
      
      console.log('[DEBUG] renderTable - Received records:', JSON.stringify(records, null, 2), 'Year:', year, 'Month:', month);

      if (!Array.isArray(records) || records.length === 0) {
        // 年月の指定がない場合は現在の年月を使用
        const displayDate = new Date();
        const displayYear = year || displayDate.getFullYear();
        const displayMonth = month || (displayDate.getMonth() + 1);
        attendanceEl.innerHTML = `<div class="empty-result">${displayYear}年${displayMonth}月の勤怠記録はありません。<br><br>以下の理由が考えられます：<br>・打刻データが登録されていない<br>・LINE UserIDと従業員情報が正しく紐づけられていない<br><br>LINEボットに「出勤」「退勤」などのコマンドを送信して打刻してください。</div>`;
        console.warn('[DEBUG] renderTable: 勤怠レコードが空または配列ではありません', records);
        return;
      }
      
      // デバッグ情報 - レコードの内容を詳細表示
      console.log('[DEBUG] 表示するレコード数:', records.length);
      if (records.length > 0) {
        console.log('[DEBUG] 最初のレコードサンプル:', JSON.stringify(records[0], null, 2));
      }
      
      // APIが返すデータ形式を検証
      const recordsWithValidation = records.map(rec => {
        // 必須フィールドのチェック
        if (!rec.date) {
          console.warn('[DEBUG] 日付がないレコード:', rec);
          // 日付を設定
          if (rec.clockEvents && rec.clockEvents.length > 0 && rec.clockEvents[0].date) {
            rec.date = rec.clockEvents[0].date;
            console.log('[DEBUG] clockEventsから日付を取得:', rec.date);
          }
        }
        
        // clockEvents配列のチェック
        if (!rec.clockEvents || !Array.isArray(rec.clockEvents)) {
          console.warn('[DEBUG] 打刻イベントがないか無効なレコード:', rec);
          rec.clockEvents = [];
        }
        
        return rec;
      }).filter(rec => rec.date); // 日付がないレコードは除外
      
      // 有効なレコードがない場合
      if (recordsWithValidation.length === 0) {
        attendanceEl.innerHTML = '<div class="empty-result">有効な勤怠記録が見つかりませんでした。データ形式が正しくないか、勤怠情報がありません。</div>';
        return;
      }
      
      // 現在の年月を取得 (引数で渡されたものを優先)
      const currentDisplayDate = new Date();
      const displayYear = year || currentDisplayDate.getFullYear();
      const displayMonth = month || (currentDisplayDate.getMonth() + 1);
      
      let html = `<h2>${displayYear}年${displayMonth}月の勤怠記録</h2>`;
      html += '<div class="table-container">';
      html += '<table>';
      html += '<thead><tr>';
      html += '<th>日付</th><th>出勤</th><th>退勤</th><th>労働時間</th><th>休憩</th><th>打刻記録</th>';
      html += '</tr></thead><tbody>';
      
      let totalWorkSeconds = 0;
      let totalBreakMinutes = 0;
      const workDaysSet = new Set();
      
      recordsWithValidation.forEach(rec => {
        // レコードの検証
        if (!rec || typeof rec !== 'object') {
          console.warn('[DEBUG] 無効なレコード:', rec);
          return; // 無効なレコードはスキップ
        }
        
        // 日付フォーマットのチェック
        const dateDisplay = formatDate(rec.date);
        
        // 出退勤時間から時間部分のみ抽出する関数
        const formatTimeOnly = (timeStr) => {
          if (!timeStr) return '-';
          // HH:MM:SS 形式から HH:MM のみ抽出
          const match = timeStr.match(/^(\d{1,2}:\d{1,2})/);
          return match ? match[1] : timeStr;
        };
        
        const sortedEvents = (rec.clockEvents || []).sort((a, b) => {
          if (!a || !a.time) return 1;
          if (!b || !b.time) return -1;
          return a.time.localeCompare(b.time);
        });
        
        const allClockEventsText = sortedEvents.map(event => {
          if (!event || !event.time || !event.type) {
            console.warn('[DEBUG] 無効な打刻イベント:', event);
            return '';
          }
          // 時間の表示を短くする
          const timeOnly = formatTimeOnly(event.time);
          return `${timeOnly} ${event.type}`;
        }).filter(text => text).join('<br>');
        
        let workHoursDisplay = '';
        if (rec.workingHours) {
          // workingHours が HH.mm 形式の場合や、単純な時間数の場合を考慮
          const hoursMatch = String(rec.workingHours).match(/^(\d+)(?:\.(\d+))?$/);
          if (hoursMatch) {
            const hours = parseInt(hoursMatch[1]);
            const minutesFraction = parseFloat("0." + (hoursMatch[2] || "0")); // 8.5時間などを考慮
            totalWorkSeconds += hours * 3600 + minutesFraction * 3600; 
          }
          const colorClass = parseFloat(rec.workingHours) >= 8 ? 'text-success' : (parseFloat(rec.workingHours) < 6 ? 'text-danger' : '');
          workHoursDisplay = `<span class="${colorClass}">${rec.workingHours}h</span>`;
        }
        
        if (rec.breakMinutes) {
          const breakM = parseInt(rec.breakMinutes);
          if (!isNaN(breakM)) {
            totalBreakMinutes += breakM;
          }
        }

        // 実働日数のカウント (出勤記録がある日をカウント)
        if (rec.workStart) { // workStart があればその日を勤務日とする
            workDaysSet.add(rec.date);
        }
        
        html += `<tr>`;
        html += `<td>${dateDisplay}</td>`;
        html += `<td class="time-value">${formatTimeOnly(rec.workStart) || '-'}</td>`;
        html += `<td class="time-value">${formatTimeOnly(rec.workEnd) || '-'}</td>`;
        html += `<td>${workHoursDisplay || '-'}</td>`;
        html += `<td>${rec.breakMinutes ? rec.breakMinutes + '分' : '-'}</td>`;
        html += `<td class="events-cell">${allClockEventsText || '-'}</td>`;
        html += `</tr>`;
      });
      
      html += '</tbody></table>';
      html += '</div>';
      
      attendanceEl.innerHTML = html;

      // 集計結果の表示
      const totalWorkHours = Math.floor(totalWorkSeconds / 3600);
      const totalWorkRemainderMinutes = Math.floor((totalWorkSeconds % 3600) / 60);
      document.getElementById('total-work-time').textContent = `${totalWorkHours}時間${totalWorkRemainderMinutes}分`;

      const totalBreakHours = Math.floor(totalBreakMinutes / 60);
      const totalBreakRemainderMinutes = totalBreakMinutes % 60;
      if (totalBreakHours > 0){
        document.getElementById('total-break-time').textContent = `${totalBreakHours}時間${totalBreakRemainderMinutes}分`;
      } else {
        document.getElementById('total-break-time').textContent = `${totalBreakRemainderMinutes}分`;
      }
      
      document.getElementById('work-days').textContent = `${workDaysSet.size}日`;
    }
    
    // 日付を「MM/DD (曜日)」形式にフォーマット
    function formatDate(dateStr) {
      if (!dateStr) return '-';
      
      console.log('[DEBUG] formatDate - input dateStr:', dateStr, typeof dateStr);

      const date = new Date(dateStr);
      if (isNaN(date.getTime())) {
        console.warn('[DEBUG] formatDate - Invalid date string:', dateStr);
        return dateStr;
      }
      
      const weekdays = ['日', '月', '火', '水', '木', '金', '土'];
      const month = date.getMonth() + 1;
      const day = date.getDate();
      const weekday = weekdays[date.getDay()];
      
      return `${month}/${day} (${weekday})`;
    }
  </script>
</body>
</html>
