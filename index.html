<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>勤怠管理表 簡易ビューア</title>
  <style>
    :root {
      --primary-color: #4a6da7;
      --secondary-color: #f5f7fa;
      --accent-color: #5c8bdc;
      --text-color: #333;
      --border-color: #ddd;
      --error-color: #e74c3c;
      --success-color: #2ecc71;
    }
    
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    
    body {
      font-family: 'Hiragino Sans', 'Hiragino Kaku Gothic ProN', Meiryo, sans-serif;
      line-height: 1.6;
      color: var(--text-color);
      background-color: #f9f9f9;
      padding: 16px;
    }
    
    .container {
      max-width: 800px;
      margin: 0 auto;
      background-color: white;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      padding: 24px;
    }
    
    h1 {
      font-size: 1.5rem;
      color: var(--primary-color);
      margin-bottom: 1.5rem;
      text-align: center;
      font-weight: 600;
    }
    
    #attendance {
      margin-top: 1.5rem;
    }
    
    .empty-result {
      text-align: center;
      padding: 20px;
      color: #777;
      font-style: italic;
    }
    
    .error {
      color: var(--error-color);
      margin-top: 1rem;
      padding: 10px;
      background-color: rgba(231, 76, 60, 0.1);
      border-radius: 4px;
      display: none;
    }
    
    .loading {
      text-align: center;
      padding: 20px;
      color: #555;
    }
    
    .loading::after {
      content: "...";
      animation: dots 1.5s infinite;
    }
    
    @keyframes dots {
      0%, 20% { content: "."; }
      40% { content: ".."; }
      60%, 100% { content: "..."; }
    }
    
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 1rem;
      font-size: 0.95rem;
    }
    
    th, td {
      padding: 12px 8px;
      border: 1px solid var(--border-color);
      text-align: left;
    }
    
    th {
      background-color: var(--secondary-color);
      font-weight: 600;
      position: sticky;
      top: 0;
      z-index: 10;
    }
    
    tr:nth-child(even) {
      background-color: #f9f9f9;
    }
    
    tr:hover {
      background-color: #f0f4f8;
    }
    
    .time-value {
      font-family: monospace;
      white-space: nowrap;
    }
    
    .events-cell {
      font-size: 0.9rem;
    }
    
    .text-success {
      color: var(--success-color);
      font-weight: bold;
    }
    
    .text-danger {
      color: var(--error-color);
      font-weight: bold;
    }
    
    .browser-error {
      text-align: center;
      padding: 30px 20px;
      color: var(--error-color);
      font-weight: bold;
    }
    
    .browser-error p {
      margin-bottom: 10px;
    }
    
    .user-info {
      text-align: center;
      margin-bottom: 20px;
      font-size: 0.9rem;
      color: #666;
    }
    
    .user-name {
      font-weight: bold;
      color: var(--primary-color);
    }
    
    /* 手動入力フォーム用のスタイル */
    .manual-form {
      background-color: var(--secondary-color);
      padding: 15px;
      border-radius: 6px;
      margin-bottom: 20px;
    }
    
    .form-row {
      margin-bottom: 12px;
    }
    
    .form-row label {
      display: block;
      margin-bottom: 4px;
      font-weight: 500;
      font-size: 0.9em;
    }
    
    .form-row input {
      width: 100%;
      padding: 8px;
      border: 1px solid var(--border-color);
      border-radius: 4px;
      font-size: 16px;
    }
    
    .form-row button {
      background-color: var(--primary-color);
      color: white;
      border: none;
      padding: 10px 15px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 16px;
      width: 100%;
    }
    
    .form-row button:hover {
      background-color: var(--accent-color);
    }
    
    .form-toggle {
      text-align: center;
      margin-top: 15px;
      font-size: 0.9em;
      color: var(--accent-color);
      cursor: pointer;
      text-decoration: underline;
    }
    
    @media (max-width: 600px) {
      .container {
        padding: 16px 12px;
      }
      
      th, td {
        padding: 8px 4px;
        font-size: 0.85rem;
      }
      
      .events-cell {
        font-size: 0.8rem;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>勤怠管理表</h1>
    
    <div id="user-display" class="user-info" style="display: none;">
      <!-- <div class="loading">ユーザー情報を読み込み中</div> -->
    </div>
    
    <div class="controls" style="margin-bottom: 1.5rem; text-align: center;">
      <label for="month-year-selector" style="margin-right: 8px; font-weight: 500;">表示月:</label>
      <select id="month-year-selector" style="padding: 8px 12px; border-radius: 4px; border: 1px solid var(--border-color); font-size: 16px; background-color: #fff; max-width: 150px; cursor: pointer; appearance: auto;">
        <!-- 選択肢はJavaScriptで動的に生成 -->
      </select>
      

    </div>
    
    <div id="browser-error" class="browser-error" style="display: none;">
      <p>このページはLINEアプリからのみアクセスできます。</p>
      <p>勤怠確認はLINEアプリから行ってください。</p>
    </div>
    
    <div id="attendance"></div>
    <div class="error" id="error"></div>
    
    <div class="summary-section" style="margin-top: 1.5rem; padding: 15px; background-color: var(--secondary-color); border-radius: 6px; display: flex; justify-content: space-around;">
      <div>総労働時間: <span id="total-work-time">-</span></div>
      <div>総休憩時間: <span id="total-break-time">-</span></div>
      <div>実働日数: <span id="work-days">-</span></div>
    </div>
    
    <!-- 問題診断ボタン（通常は非表示） -->
    <div id="debug-section" style="margin-top: 20px; display: none; text-align: center;">
      <button id="debug-button" style="padding: 8px 15px; background-color: #f5f5f5; border: 1px solid #ddd; border-radius: 4px;">問題診断</button>
      <div id="debug-info" style="margin-top: 10px; padding: 10px; border: 1px solid #ddd; border-radius: 4px; background-color: #f9f9f9; display: none; text-align: left; font-size: 0.8rem;"></div>
    </div>
  </div>
  
  <!-- LIFF SDK -->
  <script charset="utf-8" src="https://static.line-scdn.net/liff/edge/2/sdk.js"></script>
  
  <script>
    // 最新のAPIエンドポイント
    const API_URL = 'https://script.google.com/macros/s/AKfycbxCrXq-iEvolakShQ6b55cjxoYRpYqq1Nxl2EYcpRFG1TNYq58vzvBsI9aH3lY7gMM/exec';
    let isLiffInitialized = false;
    let currentLineUserId = null;
    
    // グローバル変数
    let pendingScriptElements = []; // スクリプトタグの参照を保持
    const DEBUG_MODE = true; // デバッグ情報を出力する
    
    // デバッグログ用関数
    function logDebug(message, data = null) {
      if (DEBUG_MODE) {
        if (data) {
          console.log('[DEBUG]', message, data);
        } else {
          console.log('[DEBUG]', message);
        }
      }
    }
    
    // ページ読み込み時にLIFFを初期化
    document.addEventListener('DOMContentLoaded', function() {
      // クエリパラメータからデバッグモードを確認
      const urlParams = new URLSearchParams(window.location.search);
      const isDebugMode = urlParams.get('debug') === 'true';
      const isTestMode = urlParams.get('test') === 'true';
      
      // デバッグモードなら問題診断ボタンを表示
      if (isDebugMode) {
        document.getElementById('debug-section').style.display = 'block';
        
        // 問題診断ボタンのイベントリスナー
        document.getElementById('debug-button').addEventListener('click', function() {
          const debugInfoEl = document.getElementById('debug-info');
          
          // システム情報を収集
          let debugInfo = '';
          
          // LIFF情報
          debugInfo += '<h4>LIFF情報</h4>';
          debugInfo += `<p>LIFF初期化: ${isLiffInitialized ? '成功' : '未完了'}</p>`;
          
          if (window.liff) {
            try {
              debugInfo += `<p>LIFF SDK: 利用可能</p>`;
              debugInfo += `<p>LINEアプリ内: ${liff.isInClient() ? 'はい' : 'いいえ'}</p>`;
              debugInfo += `<p>ログイン状態: ${liff.isLoggedIn() ? 'ログイン済み' : '未ログイン'}</p>`;
            } catch (e) {
              debugInfo += `<p>LIFF情報エラー: ${e.message}</p>`;
            }
          } else {
            debugInfo += `<p>LIFF SDK: 利用不可</p>`;
          }
          
          // ブラウザ情報
          debugInfo += '<h4>ブラウザ情報</h4>';
          debugInfo += `<p>User Agent: ${navigator.userAgent}</p>`;
          
          // API情報
          debugInfo += '<h4>API情報</h4>';
          debugInfo += `<p>エンドポイント: ${API_URL}</p>`;
          
          // LINE UserID情報
          if (currentLineUserId) {
            debugInfo += '<h4>LINE情報</h4>';
            debugInfo += `<p>LINE User ID: ${currentLineUserId}</p>`;
          }
          
          // API接続テスト
          debugInfo += '<h4>API接続テスト</h4>';
          if (currentLineUserId) {
            const testUrl = `${API_URL}?action=getMonthlyAttendance&lineUserId=${encodeURIComponent(currentLineUserId)}&jsonp=console.log`;
            debugInfo += `<p>API接続テスト: <a href="${testUrl}" target="_blank">直接接続テスト</a> (新しいタブで開きます)</p>`;
            debugInfo += '<p>※直接接続テストリンクをクリックしてJSON応答が表示されるか確認してください</p>';
            
            // 接続テスト用のリンクを追加
            const directTestUrl = `${API_URL}?action=ping&lineUserId=${encodeURIComponent(currentLineUserId)}`;
            debugInfo += `<p>単純なAPI接続テスト: <a href="${directTestUrl}" target="_blank">Ping</a></p>`;
          }
          
          // CORS状態テスト
          debugInfo += '<h4>CORS状態テスト</h4>';
          debugInfo += '<div id="cors-test-result">テスト実行中...</div>';
          
          // ユーザーへの指示
          debugInfo += '<h4>問題解決手順</h4>';
          debugInfo += '<ol>';
          debugInfo += '<li>上記の接続テストリンクで直接APIを呼び出してみてください</li>';
          debugInfo += '<li>LINEボットに「出勤」や「退勤」などのコマンドを送り、打刻してください</li>';
          debugInfo += '<li>問題が解決しない場合は、管理者に表示されているLINE User IDを伝えてください</li>';
          debugInfo += '</ol>';
          
          // 表示/非表示を切り替え
          if (debugInfoEl.style.display === 'none') {
            debugInfoEl.innerHTML = debugInfo;
            debugInfoEl.style.display = 'block';
            
            // CORS状態テスト実行
            testCorsStatus();
          } else {
            debugInfoEl.style.display = 'none';
          }
        });
      }
      
      // LIFF初期化を実行
      initializeLiff().catch(error => {
        console.error('初期化エラー:', error);
        showError('アプリの初期化中にエラーが発生しました。');
      });
    });
    
    // CORS状態をテストする関数
    function testCorsStatus() {
      const resultElement = document.getElementById('cors-test-result');
      if (!resultElement) return;
      
      // テスト用のURLを設定
      const testUrl = `${API_URL}?action=ping&t=${Date.now()}`;
      
      // フェッチAPIでテスト
      fetch(testUrl, {
        method: 'GET',
        mode: 'cors',
        credentials: 'omit'
      })
      .then(response => {
        if (response.ok) {
          resultElement.innerHTML = `<span style="color:green">✓ CORSリクエスト成功</span>`;
          return response.text();
        } else {
          resultElement.innerHTML = `<span style="color:red">✗ CORSリクエスト失敗 (HTTP ${response.status})</span>`;
          throw new Error(`HTTP error ${response.status}`);
        }
      })
      .then(data => {
        resultElement.innerHTML += `<br>応答: ${data}`;
      })
      .catch(error => {
        console.error('CORS Test Error:', error);
        resultElement.innerHTML = `<span style="color:red">✗ CORSテスト失敗: ${error.message}</span><br>JSONPによる通信が必要です`;
        
        // JSONPでのフォールバックテスト
        resultElement.innerHTML += `<br>JSONPテスト実行中...`;
        const testJsonpUrl = `${API_URL}?action=ping&jsonp=handleJsonpTest&t=${Date.now()}`;
        
        // グローバルコールバック関数を定義
        window.handleJsonpTest = function(data) {
          resultElement.innerHTML += `<br><span style="color:green">✓ JSONPテスト成功</span><br>応答: ${JSON.stringify(data)}`;
          delete window.handleJsonpTest;
        };
        
        // スクリプトタグを作成
        const script = document.createElement('script');
        script.src = testJsonpUrl;
        script.onerror = function() {
          resultElement.innerHTML += `<br><span style="color:red">✗ JSONPテストも失敗</span>`;
          delete window.handleJsonpTest;
        };
        
        document.body.appendChild(script);
      });
    }
    
    // 月年セレクターを生成 (例: 過去12ヶ月)
    function populateMonthYearSelector() {
        const select = document.getElementById('month-year-selector');
        if (!select) {
            console.error('[DEBUG] month-year-selectorが見つかりません');
            return;
        }
        
        // 既存の選択肢をクリア
        select.innerHTML = '';
        
        // イベントリスナーの削除（重複登録防止）
        select.removeEventListener('change', handleMonthYearChange);
        
        const today = new Date();
        // 今月と過去11ヶ月分の選択肢を追加
        for (let i = 0; i < 12; i++) {
            let date = new Date(today.getFullYear(), today.getMonth() - i, 1);
            let year = date.getFullYear();
            let month = date.getMonth() + 1;
            let option = document.createElement('option');
            option.value = `${year}-${month.toString().padStart(2, '0')}`;
            option.textContent = `${year}年${month}月`;
            select.appendChild(option);
        }
        
        // イベントリスナーを追加
        select.addEventListener('change', handleMonthYearChange);
        
        logDebug('月年セレクター初期化完了 - 選択肢数:', select.options.length);
    }
    
    // 月年変更イベントハンドラ（別関数化して重複登録防止）
    function handleMonthYearChange(event) {
        const selectedMonthYear = event.target.value;
        if (currentLineUserId && selectedMonthYear) {
            const [year, month] = selectedMonthYear.split('-');
            console.log(`月年変更: ${year}年${month}月`);
            fetchUserAttendance(currentLineUserId, parseInt(year), parseInt(month));
        } else {
            console.warn('[DEBUG] 月年変更 - ユーザーIDまたは選択値が不正:', 
                         'UserID:', currentLineUserId, 
                         'Selected:', selectedMonthYear);
        }
    }
    
    // LIFFの初期化
    async function initializeLiff() {
      try {
        // 開発者モードチェック（クエリパラメータ）
        const urlParams = new URLSearchParams(window.location.search);
        const isDevMode = urlParams.get('dev') === 'true';
        
        if (isDevMode) {
          console.log('開発者モード: LIFF初期化をスキップします');
          const mockUserId = urlParams.get('mockUserId');
          if (mockUserId) {
            // ユーザーIDを保存
            currentLineUserId = mockUserId;
            
            // 月年セレクターを初期化
            populateMonthYearSelector();
            
            // 初回データ取得 (セレクターの現在の値に基づいて)
            const selector = document.getElementById('month-year-selector');
            if (selector && selector.value) {
                const [year, month] = selector.value.split('-');
                console.log(`初回データ取得: ${year}年${month}月`);
                await fetchUserAttendance(mockUserId, parseInt(year), parseInt(month));
            } else {
                // フォールバックとして当月データを取得
                const today = new Date();
                console.log(`初回データ取得（フォールバック）: ${today.getFullYear()}年${today.getMonth() + 1}月`);
                await fetchUserAttendance(mockUserId, today.getFullYear(), today.getMonth() + 1);
            }
          } else {
            showError('開発者モードでは mockUserId パラメータが必要です');
          }
          return;
        }
        
        // LINEブラウザチェック
        if (!window.liff) {
          console.error('LIFF SDKが利用できません。LINEアプリで開いてください。');
          showBrowserError();
          return;
        }
        
        // LIFF初期化
        await liff.init({ liffId: '2007458955-dVkEPq4E' }); // 実際のLIFF ID
        isLiffInitialized = true;
        console.log('LIFF初期化成功');
        
        // LINEブラウザで開かれているか確認
        if (!liff.isInClient()) {
          console.error('このページはLINEアプリからのみアクセスできます');
          showBrowserError();
          return;
        }
        
        // ユーザープロフィールから勤怠データを取得
        try {
          // LINEのユーザープロフィールを取得
          console.log('ユーザープロフィール取得中...');
          const profile = await liff.getProfile();
          console.log('プロフィール取得成功:', profile.displayName);
          const lineUserId = profile.userId;
          console.log('取得したLINE UserID:', lineUserId);
          
          // LINE UserIDを保存（デバッグ用）
          currentLineUserId = lineUserId;
          
          // 月年セレクターを初期化・設定
          populateMonthYearSelector(); 

          // 初回データ取得 (セレクターの現在の値に基づいて)
          const selector = document.getElementById('month-year-selector');
          if (selector && selector.value) {
              const [year, month] = selector.value.split('-');
              console.log(`初回データ取得(LINE認証): ${year}年${month}月`);
              await fetchUserAttendance(lineUserId, parseInt(year), parseInt(month));
          } else {
            // フォールバックとして当月データを取得 (セレクターが何らかの理由で空の場合)
            const today = new Date();
            console.log(`初回データ取得（LINE認証・フォールバック）: ${today.getFullYear()}年${today.getMonth() + 1}月`);
            await fetchUserAttendance(lineUserId, today.getFullYear(), today.getMonth() + 1);
          }
          
        } catch (profileError) {
          console.error('プロフィール取得失敗:', profileError);
          showError('LINEプロフィールの取得に失敗しました: ' + profileError.message);
        }
        
      } catch (err) {
        console.error('LIFF初期化エラー:', err.message, err.stack);
        showError('LINEへの接続に失敗しました。しばらく経ってからもう一度お試しください。');
      }
    }
    
    // ブラウザエラー表示
    function showBrowserError() {
      document.getElementById('user-display').style.display = 'none';
      document.getElementById('browser-error').style.display = 'block';
      document.getElementById('attendance').style.display = 'none';
    }
    
    // LINE認証での勤怠データ取得
    async function fetchUserAttendance(lineUserId, year, month) {
      const attendanceEl = document.getElementById('attendance');
      const errorEl = document.getElementById('error');
      
      try {
        // ローディング表示
        attendanceEl.innerHTML = '<div class="loading">勤怠データを取得中</div>';
        
        logDebug('fetchUserAttendance - Received lineUserId:', lineUserId, 'Year:', year, 'Month:', month);

        if (!lineUserId) {
          console.error('[DEBUG] lineUserId is null or empty.');
          showError('ユーザーIDを取得できませんでした');
          attendanceEl.innerHTML = '<div class="empty-result">ユーザー情報が取得できませんでした。<br>もう一度お試しください。</div>';
          return;
        }
        
        // APIリクエストURLを構築
        const currentDate = new Date();
        const requestYear = year || currentDate.getFullYear();
        const requestMonth = month || (currentDate.getMonth() + 1);

        // URLクエリパラメータの構築
        const baseUrl = API_URL;
        const params = {
          action: 'getMonthlyAttendance',
          lineUserId: lineUserId,
          year: requestYear,
          month: requestMonth.toString().padStart(2, '0')
        };
        
        // パラメータの取得
        const urlParams = new URLSearchParams(window.location.search);
        const isDebugMode = urlParams.get('debug') === 'true';
        
        if (isDebugMode) {
          params.debug = 'true';
        }
        
        // 複数の取得方法を試みる
        try {
          // 最初に固定関数名でJSONPを試す (最も信頼性が高い方法)
          logDebug('固定関数名JSONPで勤怠データ取得を試みます');
          let data = await fetchDataWithFixedCallback(baseUrl, params);
          processAndRenderData(data, requestYear, requestMonth);
          return;
        }
        catch (fixedJsonpError) {
          console.error('[DEBUG] 固定関数名JSONP失敗:', fixedJsonpError);
          
          try {
            // 次にjsonpパラメータでJSONPを試す (Google Apps Scriptで一般的)
            logDebug('jsonpパラメータで勤怠データ取得を試みます');
            let data = await fetchDataWithJsonp(baseUrl, params, 'jsonp');
            processAndRenderData(data, requestYear, requestMonth);
            return;
          }
          catch (jsonpError) {
            console.error('[DEBUG] jsonpパラメータJSONP失敗:', jsonpError);
            
            try {
              // 次にcallbackパラメータでJSONPを試す
              logDebug('callbackパラメータで勤怠データ取得を試みます');
              let data = await fetchDataWithJsonp(baseUrl, params, 'callback');
              processAndRenderData(data, requestYear, requestMonth);
              return;
            }
            catch (callbackError) {
              console.error('[DEBUG] callbackパラメータJSONP失敗:', callbackError);
              
              try {
                // フォールバック: 直接のfetchリクエスト
                logDebug('直接Fetchで勤怠データ取得を試みます');
                
                // URLパラメータをエンコード
                const queryString = Object.entries(params)
                  .map(([key, value]) => `${encodeURIComponent(key)}=${encodeURIComponent(value)}`)
                  .join('&');
                
                const response = await fetch(`${baseUrl}?${queryString}`, {
                  method: 'GET',
                  mode: 'cors',
                  credentials: 'omit',
                  headers: {
                    'Accept': 'application/json'
                  }
                });
                if (!response.ok) {
                  throw new Error(`HTTP error ${response.status}`);
                }
                
                const data = await response.json();
                processAndRenderData(data, requestYear, requestMonth);
                return;
              }
              catch (fetchError) {
                console.error('[DEBUG] 直接Fetch失敗:', fetchError);
                
                // 最後の手段: IFRAMEを使った擬似的なJSONP
                try {
                  logDebug('IFRAMEでの取得を試みます');
                  let data = await fetchWithIframe(baseUrl, params);
                  processAndRenderData(data, requestYear, requestMonth);
                  return;
                } catch (iframeError) {
                  console.error('[DEBUG] IFRAME取得失敗:', iframeError);
                  showError('すべての方法でデータ取得に失敗しました');
                  attendanceEl.innerHTML = '<div class="empty-result">サーバーに接続できませんでした。<br>ネットワーク接続を確認し、しばらく経ってから再度お試しください。</div>';
                }
              }
            }
          }
        }
      } catch (error) {
        console.error('[DEBUG] 全体的なエラー:', error);
        showError(`データ取得中にエラーが発生しました: ${error.message}`);
        attendanceEl.innerHTML = '<div class="empty-result">予期しないエラーが発生しました。<br>しばらく経ってから再度お試しください。</div>';
      }
    }
    
    /**
     * 固定関数名を使用したJSONPリクエスト
     * Google Apps Scriptによっては動的な関数名を処理できないため、固定名を使う
     */
    function fetchDataWithFixedCallback(baseUrl, params) {
      return new Promise((resolve, reject) => {
        // 既存のスクリプトタグをクリーンアップ
        cleanupPendingScripts();
        
        // 固定のコールバック関数名
        const callbackName = 'kintaiDataCallback';
        
        // 古いコールバック関数が存在する場合はクリア
        if (window[callbackName]) {
          delete window[callbackName];
        }
        
        // コピーを作成してパラメータにコールバック名を追加
        const jsonpParams = { ...params };
        jsonpParams.jsonp = callbackName; // 'jsonp'パラメータを使用
        
        // URLクエリストリングを構築
        const queryString = Object.entries(jsonpParams)
          .map(([key, value]) => `${encodeURIComponent(key)}=${encodeURIComponent(value)}`)
          .join('&');
        
        // JSONP用のURLを構築
        const jsonpUrl = `${baseUrl}?${queryString}`;
        
        logDebug(`固定関数名JSONPリクエストURL: ${jsonpUrl}`);
        
        // グローバルコールバック関数を定義
        window[callbackName] = function(data) {
          logDebug('固定関数名JSONP応答受信');
          
          // スクリプトタグをクリーンアップ
          cleanupScript(script);
          
          // タイムアウトをキャンセル
          clearTimeout(timeoutId);
          
          // データを返す（コールバック関数は残しておく）
          resolve(data);
        };
        
        // スクリプトタグを作成
        const script = document.createElement('script');
        script.src = jsonpUrl;
        script.async = true;
        script.id = 'jsonp_fixed';
        
        // エラーハンドラ
        script.onerror = function(e) {
          logDebug('固定関数名JSONPスクリプトエラー:', e);
          
          // スクリプトタグをクリーンアップ
          cleanupScript(script);
          
          // タイムアウトをキャンセル
          clearTimeout(timeoutId);
          
          // エラーを返す
          reject(new Error('固定関数名JSONPスクリプトエラー'));
        };
        
        // タイムアウト処理
        const timeoutId = setTimeout(() => {
          logDebug('固定関数名JSONPリクエストがタイムアウトしました:', jsonpUrl);
          
          // スクリプトタグをクリーンアップ
          cleanupScript(script);
          
          // エラーを返す
          reject(new Error('固定関数名JSONPリクエストがタイムアウトしました'));
        }, 20000); // 20秒でタイムアウト
        
        // スクリプトタグの参照を保持
        pendingScriptElements.push(script);
        
        // DOMに追加して読み込みを開始
        document.body.appendChild(script);
        
        logDebug('固定関数名JSONP リクエスト送信');
      });
    }
    
    /**
     * IFRAMEを使ったデータ取得（最終手段）
     * CORSやJSONPが使えない場合のフォールバック
     */
    function fetchWithIframe(baseUrl, params) {
      return new Promise((resolve, reject) => {
        // URLクエリストリングを構築
        const queryString = Object.entries(params)
          .map(([key, value]) => `${encodeURIComponent(key)}=${encodeURIComponent(value)}`)
          .join('&');
        
        // IFRAME用のURLを構築
        const iframeUrl = `${baseUrl}?${queryString}&format=text`;
        
        logDebug(`IFRAME URL: ${iframeUrl}`);
        
        // IFRAMEを作成
        const iframe = document.createElement('iframe');
        iframe.style.display = 'none';
        iframe.src = iframeUrl;
        
        // タイムアウト処理
        const timeoutId = setTimeout(() => {
          logDebug('IFRAMEリクエストがタイムアウトしました');
          document.body.removeChild(iframe);
          reject(new Error('IFRAMEリクエストがタイムアウトしました'));
        }, 20000); // 20秒でタイムアウト
        
        // ロード完了時の処理
        iframe.onload = function() {
          try {
            clearTimeout(timeoutId);
            
            // IFRAMEの内容を取得
            let content;
            try {
              // セキュリティ制限のため、これは通常失敗する
              content = iframe.contentDocument.body.textContent;
            } catch (e) {
              // フォールバック: メッセージングAPIを使用
              window.addEventListener('message', function(event) {
                if (event.source === iframe.contentWindow) {
                  try {
                    const data = JSON.parse(event.data);
                    resolve(data);
                  } catch (e) {
                    reject(new Error('IFRAMEからのデータをパースできませんでした'));
                  }
                  document.body.removeChild(iframe);
                }
              }, { once: true });
              
              // IFRAMEにメッセージを送信
              iframe.contentWindow.postMessage('getData', '*');
              return;
            }
            
            // テキストデータをJSONとしてパース
            try {
              const data = JSON.parse(content);
              resolve(data);
            } catch (e) {
              reject(new Error('IFRAMEからのデータをパースできませんでした'));
            }
            
            // IFRAMEを削除
            document.body.removeChild(iframe);
          } catch (e) {
            clearTimeout(timeoutId);
            document.body.removeChild(iframe);
            reject(new Error('IFRAMEの処理中にエラーが発生しました: ' + e.message));
          }
        };
        
        // エラーハンドラ
        iframe.onerror = function() {
          clearTimeout(timeoutId);
          document.body.removeChild(iframe);
          reject(new Error('IFRAMEの読み込みに失敗しました'));
        };
        
        // DOMに追加
        document.body.appendChild(iframe);
      });
    }
    
    /**
     * JSONP（特定のコールバックパラメータ名）でデータを取得する関数
     */
    function fetchDataWithJsonp(baseUrl, params, callbackParamName = 'jsonp') {
      return new Promise((resolve, reject) => {
        // 既存のスクリプトタグをクリーンアップ
        cleanupPendingScripts();
        
        // 一意のコールバック関数名を生成
        const callbackName = 'jsonpCallback_' + Date.now() + '_' + Math.random().toString(36).substring(2, 9);
        
        // コピーを作成してパラメータにコールバック名を追加
        const jsonpParams = { ...params };
        jsonpParams[callbackParamName] = callbackName;
        
        // URLクエリストリングを構築
        const queryString = Object.entries(jsonpParams)
          .map(([key, value]) => `${encodeURIComponent(key)}=${encodeURIComponent(value)}`)
          .join('&');
        
        // JSONP用のURLを構築
        const jsonpUrl = `${baseUrl}?${queryString}`;
        
        logDebug(`JSONPリクエストURL (${callbackParamName}): ${jsonpUrl}`);
        
        // コールバック関数を定義
        window[callbackName] = function(data) {
          logDebug('JSONP応答受信:', callbackName);
          
          // スクリプトタグをクリーンアップ
          cleanupScript(script);
          
          // タイムアウトをキャンセル
          clearTimeout(timeoutId);
          
          // コールバック関数の登録を解除
          delete window[callbackName];
          
          // データを返す
          resolve(data);
        };
        
        // スクリプトタグを作成
        const script = document.createElement('script');
        script.src = jsonpUrl;
        script.async = true;
        script.id = 'jsonp_' + callbackName;
        
        // エラーハンドラ
        script.onerror = function(e) {
          logDebug('JSONPスクリプトエラー:', e);
          
          // スクリプトタグをクリーンアップ
          cleanupScript(script);
          
          // タイムアウトをキャンセル
          clearTimeout(timeoutId);
          
          // コールバック関数の登録を解除
          delete window[callbackName];
          
          // エラーを返す
          reject(new Error(`JSONPスクリプトエラー (${callbackParamName})`));
        };
        
        // タイムアウト処理
        const timeoutId = setTimeout(() => {
          logDebug(`JSONPリクエストがタイムアウトしました (${callbackParamName}):`, jsonpUrl);
          
          // スクリプトタグをクリーンアップ
          cleanupScript(script);
          
          // コールバック関数の登録を解除
          delete window[callbackName];
          
          // エラーを返す
          reject(new Error(`データ取得がタイムアウトしました (${callbackParamName})`));
        }, 20000); // 20秒でタイムアウト
        
        // スクリプトタグの参照を保持
        pendingScriptElements.push(script);
        
        // DOMに追加して読み込みを開始
        document.body.appendChild(script);
        
        logDebug(`JSONP リクエスト送信 (${callbackParamName}):`, callbackName);
      });
    }
    
    /**
     * スクリプトタグをクリーンアップする関数
     */
    function cleanupScript(scriptTag) {
      try {
        // DOMから削除
        if (scriptTag && scriptTag.parentNode) {
          scriptTag.parentNode.removeChild(scriptTag);
        }
        
        // 追跡配列から削除
        pendingScriptElements = pendingScriptElements.filter(s => s !== scriptTag);
      } catch (e) {
        console.warn('[DEBUG] スクリプト要素削除エラー:', e);
      }
    }
    
    /**
     * 保留中のすべてのスクリプトタグをクリーンアップする関数
     */
    function cleanupPendingScripts() {
      // 配列をコピーしてから処理（反復中に削除するため）
      const scripts = [...pendingScriptElements];
      scripts.forEach(script => {
        cleanupScript(script);
      });
      pendingScriptElements = [];
    }
    
    /**
     * データを処理して表示する関数
     */
    function processAndRenderData(data, year, month) {
      const attendanceEl = document.getElementById('attendance');
      
      // データがエラーオブジェクトの場合
      if (data && (data.status === 'error' || data.error)) {
        console.error('[DEBUG] APIエラー:', data);
        showError(data.message || data.error || 'データ取得エラー');
        attendanceEl.innerHTML = '<div class="empty-result">データ取得中にエラーが発生しました。<br>もう一度お試しください。</div>';
        return;
      }
      
      // データが配列の場合
      if (Array.isArray(data)) {
        if (data.length > 0) {
          logDebug('有効なデータを受信しました。表示処理を開始します。');
          renderTable(data, year, month);
        } else {
          // データは配列だが空の場合（勤怠記録なし）
          console.warn('[DEBUG] 勤怠データが空の配列です。LINE UserID:', currentLineUserId);
          
          // デバッグモードの場合はユーザーIDも表示
          const urlParams = new URLSearchParams(window.location.search);
          const isDebugMode = urlParams.get('debug') === 'true';
          
          if (isDebugMode) {
            attendanceEl.innerHTML = `<div class="empty-result">${year}年${month}月の勤怠記録はありません。<br><br>以下の理由が考えられます：<br>・打刻データが登録されていない<br>・LINE UserIDと従業員情報が正しく紐づけられていない<br><br>あなたのLINE User ID:<br>${currentLineUserId}<br><br>LINEボットに「出勤」や「退勤」などのコマンドを送信してください。</div>`;
          } else {
            attendanceEl.innerHTML = `<div class="empty-result">${year}年${month}月の勤怠記録はありません。<br><br>以下の理由が考えられます：<br>・打刻データが登録されていない<br>・LINE UserIDと従業員情報が正しく紐づけられていない<br><br>LINEボットに「出勤」や「退勤」などのコマンドを送信してください。</div>`;
          }
        }
        return;
      } 
      
      // データがオブジェクトの場合
      if (typeof data === 'object' && data !== null) {
        console.warn('[DEBUG] APIから配列ではなくオブジェクトを受信しました:', data);
        
        // データがオブジェクトのプロパティ内にある可能性をチェック
        if (data.data && Array.isArray(data.data)) {
          logDebug('data.dataプロパティから配列を取得しました');
          renderTable(data.data, year, month);
          return;
        }
        
        // キー・バリュー構造のオブジェクトを配列に変換
        const recordsArray = Object.entries(data).map(([key, value]) => {
          if (typeof value === 'object' && value !== null) {
            if (!value.date) {
              value.date = key;
            }
            return value;
          }
          return null;
        }).filter(item => item !== null);
        
        if (recordsArray.length > 0) {
          logDebug('オブジェクトを配列に変換しました:', recordsArray);
          renderTable(recordsArray, year, month);
          return;
        }
      }
      
      // 予期しないデータ形式
      console.error('[DEBUG] 予期しないデータ形式:', data);
      showError('予期しないデータ形式を受信しました');
      attendanceEl.innerHTML = '<div class="empty-result">データ形式が不正です。<br>システム管理者にお問い合わせください。</div>';
    }
    
    // エラーメッセージ表示
    function showError(message) {
      const errorEl = document.getElementById('error');
      if (!errorEl) {
        console.error('[DEBUG] エラー表示要素が見つかりません。メッセージ:', message);
        return;
      }
      errorEl.textContent = message;
      errorEl.style.display = 'block';
      console.error('[DEBUG] エラー表示:', message);
      
      // 5秒後に自動的に消える
      setTimeout(() => {
        errorEl.style.display = 'none';
      }, 5000);
    }
    
    function renderTable(records, year, month) {
      const attendanceEl = document.getElementById('attendance');
      
      console.log('[DEBUG] renderTable - Received records:', JSON.stringify(records, null, 2), 'Year:', year, 'Month:', month);

      if (!Array.isArray(records) || records.length === 0) {
        // 年月の指定がない場合は現在の年月を使用
        const displayDate = new Date();
        const displayYear = year || displayDate.getFullYear();
        const displayMonth = month || (displayDate.getMonth() + 1);
        attendanceEl.innerHTML = `<div class="empty-result">${displayYear}年${displayMonth}月の勤怠記録はありません。<br><br>以下の理由が考えられます：<br>・打刻データが登録されていない<br>・LINE UserIDと従業員情報が正しく紐づけられていない<br><br>LINEボットに「出勤」「退勤」などのコマンドを送信して打刻してください。</div>`;
        console.warn('[DEBUG] renderTable: 勤怠レコードが空または配列ではありません', records);
        return;
      }
      
      // デバッグ情報 - レコードの内容を詳細表示
      console.log('[DEBUG] 表示するレコード数:', records.length);
      if (records.length > 0) {
        console.log('[DEBUG] 最初のレコードサンプル:', JSON.stringify(records[0], null, 2));
      }
      
      // APIが返すデータ形式を検証
      const recordsWithValidation = records.map(rec => {
        // 必須フィールドのチェック
        if (!rec.date) {
          console.warn('[DEBUG] 日付がないレコード:', rec);
          // 日付を設定
          if (rec.clockEvents && rec.clockEvents.length > 0 && rec.clockEvents[0].date) {
            rec.date = rec.clockEvents[0].date;
            console.log('[DEBUG] clockEventsから日付を取得:', rec.date);
          }
        }
        
        // clockEvents配列のチェック
        if (!rec.clockEvents || !Array.isArray(rec.clockEvents)) {
          console.warn('[DEBUG] 打刻イベントがないか無効なレコード:', rec);
          rec.clockEvents = [];
        }
        
        return rec;
      }).filter(rec => rec.date); // 日付がないレコードは除外
      
      // 有効なレコードがない場合
      if (recordsWithValidation.length === 0) {
        attendanceEl.innerHTML = '<div class="empty-result">有効な勤怠記録が見つかりませんでした。データ形式が正しくないか、勤怠情報がありません。</div>';
        return;
      }
      
      // 現在の年月を取得 (引数で渡されたものを優先)
      const currentDisplayDate = new Date();
      const displayYear = year || currentDisplayDate.getFullYear();
      const displayMonth = month || (currentDisplayDate.getMonth() + 1);
      
      let html = `<h2>${displayYear}年${displayMonth}月の勤怠記録</h2>`;
      html += '<div class="table-container">';
      html += '<table>';
      html += '<thead><tr>';
      html += '<th>日付</th><th>出勤</th><th>退勤</th><th>労働時間</th><th>休憩</th><th>打刻記録</th>';
      html += '</tr></thead><tbody>';
      
      let totalWorkSeconds = 0;
      let totalBreakMinutes = 0;
      const workDaysSet = new Set();
      
      recordsWithValidation.forEach(rec => {
        // レコードの検証
        if (!rec || typeof rec !== 'object') {
          console.warn('[DEBUG] 無効なレコード:', rec);
          return; // 無効なレコードはスキップ
        }
        
        // 日付フォーマットのチェック
        const dateDisplay = formatDate(rec.date);
        
        // 出退勤時間から時間部分のみ抽出する関数
        const formatTimeOnly = (timeStr) => {
          if (!timeStr) return '-';
          // HH:MM:SS 形式から HH:MM のみ抽出
          const match = timeStr.match(/^(\d{1,2}:\d{1,2})/);
          return match ? match[1] : timeStr;
        };
        
        const sortedEvents = (rec.clockEvents || []).sort((a, b) => {
          if (!a || !a.time) return 1;
          if (!b || !b.time) return -1;
          return a.time.localeCompare(b.time);
        });
        
        const allClockEventsText = sortedEvents.map(event => {
          if (!event || !event.time || !event.type) {
            console.warn('[DEBUG] 無効な打刻イベント:', event);
            return '';
          }
          // 時間の表示を短くする
          const timeOnly = formatTimeOnly(event.time);
          return `${timeOnly} ${event.type}`;
        }).filter(text => text).join('<br>');
        
        let workHoursDisplay = '';
        if (rec.workingHours) {
          // workingHours が HH.mm 形式の場合や、単純な時間数の場合を考慮
          const hoursMatch = String(rec.workingHours).match(/^(\d+)(?:\.(\d+))?$/);
          if (hoursMatch) {
            const hours = parseInt(hoursMatch[1]);
            const minutesFraction = parseFloat("0." + (hoursMatch[2] || "0")); // 8.5時間などを考慮
            totalWorkSeconds += hours * 3600 + minutesFraction * 3600; 
          }
          const colorClass = parseFloat(rec.workingHours) >= 8 ? 'text-success' : (parseFloat(rec.workingHours) < 6 ? 'text-danger' : '');
          workHoursDisplay = `<span class="${colorClass}">${rec.workingHours}h</span>`;
        }
        
        if (rec.breakMinutes) {
          const breakM = parseInt(rec.breakMinutes);
          if (!isNaN(breakM)) {
            totalBreakMinutes += breakM;
          }
        }

        // 実働日数のカウント (出勤記録がある日をカウント)
        if (rec.workStart) { // workStart があればその日を勤務日とする
            workDaysSet.add(rec.date);
        }
        
        html += `<tr>`;
        html += `<td>${dateDisplay}</td>`;
        html += `<td class="time-value">${formatTimeOnly(rec.workStart) || '-'}</td>`;
        html += `<td class="time-value">${formatTimeOnly(rec.workEnd) || '-'}</td>`;
        html += `<td>${workHoursDisplay || '-'}</td>`;
        html += `<td>${rec.breakMinutes ? rec.breakMinutes + '分' : '-'}</td>`;
        html += `<td class="events-cell">${allClockEventsText || '-'}</td>`;
        html += `</tr>`;
      });
      
      html += '</tbody></table>';
      html += '</div>';
      
      attendanceEl.innerHTML = html;

      // 集計結果の表示
      const totalWorkHours = Math.floor(totalWorkSeconds / 3600);
      const totalWorkRemainderMinutes = Math.floor((totalWorkSeconds % 3600) / 60);
      document.getElementById('total-work-time').textContent = `${totalWorkHours}時間${totalWorkRemainderMinutes}分`;

      const totalBreakHours = Math.floor(totalBreakMinutes / 60);
      const totalBreakRemainderMinutes = totalBreakMinutes % 60;
      if (totalBreakHours > 0){
        document.getElementById('total-break-time').textContent = `${totalBreakHours}時間${totalBreakRemainderMinutes}分`;
      } else {
        document.getElementById('total-break-time').textContent = `${totalBreakRemainderMinutes}分`;
      }
      
      document.getElementById('work-days').textContent = `${workDaysSet.size}日`;
    }
    
    // 日付を「MM/DD (曜日)」形式にフォーマット
    function formatDate(dateStr) {
      if (!dateStr) return '-';
      
      console.log('[DEBUG] formatDate - input dateStr:', dateStr, typeof dateStr);

      const date = new Date(dateStr);
      if (isNaN(date.getTime())) {
        console.warn('[DEBUG] formatDate - Invalid date string:', dateStr);
        return dateStr;
      }
      
      const weekdays = ['日', '月', '火', '水', '木', '金', '土'];
      const month = date.getMonth() + 1;
      const day = date.getDate();
      const weekday = weekdays[date.getDay()];
      
      return `${month}/${day} (${weekday})`;
    }
  </script>
</body>
</html>
